Для решения задачи было решено создать 3 класса:
* SHA - считает хэш SHA1 для заданной строки.
Так же этот класс может хэшировать SHA256 и SHA512. Написал еще пару тестов, для проверки его работы.
* WorkingWithQueue - работа с очередью: добавление, "разгребание" и вывод в stdout строки в заданном формате.
Потоки запускают функцию WorkingWithQueue::HashAndPrint, которая обеспечивает засыпание потоков, до выполнения условия: в очереди есть задачи.
* LiteServer - HTTP/1.1 сервер на базе OpenSSL который принимает запросы и вызывает callback функцию, добавляющую запрос в очередь.
Т.к. сервер в моей практике мне реализовывать не приходилось, с OpenSSL работать тоже, изобретал велосипед с нуля.
Lite - потому, что, возможно, он не оптимален, не универсален и не оптимизирован.
Главной задачей для меня было, что бы он запускался с заданными ему параметрами (порт, сертификат, ключ), работал в неблокирующем режиме, и поддерживает подключение нескольких клиентов.


Теперь по заданию:
1. Сервер принимает GET-запросы.
LiteServer принимает только GET запросы
2. После приёма GET-запроса сервер сразу отвечает 200 ОК с содержимым "queued", а путь страницы и строку-содержимое заголовка User-Agent помещает в очередь на обработку.
LiteServer данное требование реализует. Путь и User-Agent передается callback функции (в main), которая кладет все в очередь.
"Для реализации необходимо использовать POSIX sockets, C++20" - данное требование я не понял, решил что это остатки от чего-то и написал на C++17 как написано ниже.
3. Данную очередь "разгребают" 5 потоков. Поток достаёт из очереди информацию о запросе, считает от неё хэш SHA1 и выводит в stdout строку в формат: ...
Потоки создаются в main им передается функция WorkingWithQueue::HashAndPrint, в которой достается информация из очереди, считается хеш и выводится в заданном формате.
hitcountы хранятся в unordered_map ах каждого потока и считаюся соответственно.
"Потоки не должны находиться в активном ожидании, они должны просыпаться, когда в очереди есть задачи"
Данный алгоритм реализуется с помощью condition_variable и mutex.


Приложение реализовано в виде CMake проекта (C++ 17) на ОС Linux Mint 20.3 (теоретически приложение также должно собираться в ОС Ubuntu 18.04 или 20.04).
Используется POSIX sockets, C++17, библиотека тредов С++ threads.

Для реализации сервера была выбрана библиотека OpenSSL (версия: 1.1.1f  31 Mar 2020), усановленная командой:
sudo apt-get install libssl-dev

Для работы сервера были сгенерированы (с помощью OpenSSL) тестовый сертификат и ключ командой:
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
Файлы сертификата и ключа лежат в проекте.


По умолчанию сервер запускается по адресу:
https://localhost:4433

Для тестирования сервера использовалась утилита curl и ее команда:
curl https://localhost:4433/path --cacert cert.pem --key key.pem --header "User-Agent: test" -k
-k - для отключения проверки сертификатов.

bash скрипт запускающий несколько клиентов "параллельно" и выдающие запросы лежит в репозитории и называется:
client.sh

От себя добавил возможность задать айпи, порт, пути к сертификатам и ключу, количество тредов для "разгребания очереди" в качестве аргументов приложения (вдруг у вас где-то стоит свой тестовый сервер)
Могут быть проблемы с сертификатами при использовании клиентов, т.к. я с ними не заморачивался и заполнил от балды.


